procedure  SacarTodasLasDeColor_(colorASacar){
    /*
        Proposito:Sacar todas las bolitas del color *colorASacar* de la celda actual
        Precondicion:Ninguna
        Parametros:*colorASacar*: Color - Es el color del cual se van a sacar las bolitas
    */
    repeat(nroBolitas(colorASacar)){
        Sacar(colorASacar)
    }
}


procedure  VaciarCelda(){
    /*
        Proposito:Sacar todas las bolitas del de la celda actual
        Precondicion:Ninguna
    */
    SacarTodasLasDeColor_(Azul)
    SacarTodasLasDeColor_(Verde)
    SacarTodasLasDeColor_(Rojo)
    SacarTodasLasDeColor_(Negro)
    
}

procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /*
    Propósito:Poner **cantidadAPoner** bolitas de color **colorAPoner** en la celda actual
    Precondicion:Ninguna
    Parametros:**cantidadAPoner** Es la cantidad totoal de cuantas bolitas rojas va a poner en la celda actual
               **colorAPoner** Color del cual se va a poner la bolita en la celda actual    
    */
    repeat(cantidadAPoner){
        Poner(colorAPoner)
    }
}
procedure Mover_Si_(direccion, condicion) {
    /*
        PROPÓSITO:  Dado un color y un valor de verdad llamado condicion
        mueve el cabezal
         una celda a la direccion dada si el valor de verdad de la 
        condicion es verdadero y si no lo es, no lo mueve
        PARÁMETROS:
            * direccion: direccion - es la direccion a mover.
            * condicion: booleano - es el valor de verdad que indica verdadero
            mueve el cabezal a direccion.
        PRECONDICIONES:
            *Al menos debe haber una celda a direccion de la celda actual
    */
    if (condicion) {
        Mover(direccion)
    }
}
procedure Poner_Si_(colorAponer, condicion) {
    /*
        PROPÓSITO:  Poner una bolita del color *colorAPoner* en la celda actual dada la condicion *condicion*
        PARÁMETROS:
            * colorAponer: Color - Es el color a poner en la celda actual si se cumple la condicion
            * condicion: Booleano - es el valor de verdad que indica si se va a poner una bolita  o no
       
    */
    if (condicion) {
        Poner(direccion)
    }
}
procedure Sacar_Si_(colorASacar, condicion) {
    /*
        PROPÓSITO:  Sacar una bolita del color *colorASacar* en la celda actual dada la condicion *condicion*
        PRECONDICION: Debe haber uan bolita del color *colorASacar* en al celda actual para sacar
        PARÁMETROS:
            * colorASacar: Color - Es el color a sacar en la celda actual si se cumple la condicion
            * condicion: Booleano - es el valor de verdad que indica si se va a poner una bolita  o no
       
    */
    if (condicion) {
        Poner(direccion)
    }
}
procedure  Sacar_DeColor_(cantidadASacar, colorASacar){
      /*
    Propósito: Sacar todas las bolitas como **cantidadASacar** del color **colorASacar** haya en la celda actual
    Precondicion:Debe existir al menos al menos una bolita del color **colorASacar** en la celda actual
    Parametros:**cantidadASacar** Es la cantidad total de bolitas que se van a sacar 
               **colorASacar** Color de la bolita del cual se va a sacar
    */
    repeat(cantidadASacar){
        Sacar(colorASacar)
    }
}

function esCeldaVacía(){
    /*
        PROPOSITO:Indica si la celda ctual esta vacia
        PRECONDICION:ninguna
        TIPO: Booleano  
    */
    return( not hayBolitas(Azul) && not hayBolitas(Verde) && not hayBolitas(Negro) && not hayBolitas(Rojo) )
}

function hayAlMenosUnaDeCada(){
    /*
        PROPOSITO:Indica si en la celda actual hay al menos 1 bolita de cada color
        PRECONDICION:ninguna
        TIPO: Booleano  
    */
    return(hayBolitas(Azul) &&  hayBolitas(Verde) &&  hayBolitas(Negro) &&  hayBolitas(Rojo) )
}

procedure IrAlBorde_(direccion){
    /*
        Proposito: Ubicar el cabezal en el borde en la direccion *direccion*.
        Precondicion: Ninguna
        Parametro: *direccion*: Es la direccion en la cual se va a ubicar el cabezar
        Observacion: Si el cabezal ya está en el borde en la dirección dada, no se moverá.
    */
    while(puedeMover(direccion)){
        Mover(direccion)
    }
}
function  haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
        Proposito:indica si hay una siguiente celda en un recorrido hacia el *dirPrincipal* o el  *dirSecundaria*
        Precondicion:la direccion *dirPrincipal* y *dirsecundaria* no puede ser opuestas  ni iguales
        Parametros:*dirPrincipal* *dirSecundaria* Son las direcciones en la que se  tiene que mover
        Tipo:Booleano
    */
    return(puedeMover(dirPrincipal) || puedeMover(dirSecundaria) )
    
}

procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*
        Proposito: Ubicar el cabezal en la primera celda del recorrido en direccion *dirPrincipal* y *dirSecundaria* desde la celda actual.
        Precondiciones: *dirPrincipal* y *dirSecundaria* no pueden ser ni opuestas ni iguales.
        Parametros: *dirPrincipal* : Direccion - primera direccion a ubicar el cabezal para la primera celda del recorrido.
                    *dirSecundaria* : Direccion - segunda direccion a ubicar el cabezal para la primera celda del recorrido.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
     /*
    Proposito: Ubicar el cabezal en la siguiente celda en un recorrido en las direcciones **dirPrincipal** y **dirSecundaria**. 
               El cabezal queda en la siguiente celda del recorrido desde la celda actual.
    Precondiciones: 
        * dirPrincipal y dirSecundaria no deben ser iguales ni opuestas.
        * Debe existir una siguiente celda en el recorrido.
    Parametros:
        * dirPrincipal: Dirección - La dirección principal del recorrido.
        * dirSecundaria: Dirección - La dirección secundaria del recorrido.
    */
    if (puedeMover(dirPrincipal)) {
        Mover(dirPrincipal)
    } else {
        Mover(dirSecundaria)
        IrAlBorde_(opuesto(dirPrincipal))  
    }
}

function estoyEnElFinalDeUnRecorrido__(dirPrincipal, dirSecundaria) {

       /*propósito: indicar si estoy en el final de un recorrido mediante los
         parámetros *dirPrincipal* y *dirSecundaria*.
	     precondición: ninguna.
	     parámetros: dirPrincipal - tipo Dirección - indica la dirección principal.
                     dirSecundaria - tipo Dirección -  indica la dirección secundaria.
         resultado: un booleano, verdadero si se obtiene el opuesto de las direcciones *dirPrincipal* y *dirSecundaria*.
       */

   return (not puedeMover(opuesto(dirPrincipal)) && not puedeMover(opuesto(dirSecundaria)))

}
--------------------------------------------------------


///EJERCICIO 12

function mínimoEntre_Y_(primerNum, segundoNum){
    /*  Proposito: Describe el numero mas chico entre *primerNumero* y el *segundoNumero* 
        Precondicion: *primerNumero* y *segundoNumero* deber ser del mismo tipo
        Tipo:Numero || color || direccion : dependidiendo del tipo de valor que se ingrese como valor
        Parametros: *primerNumero*, *segundoNumero*: Numero,color,direccion : Son los valores a comparar
    */
    return (choose primerNumero when (primerNumero < segundoNumero)
                   segundoNumero otherwise     
            )
    
}

///EJERCICIO 13
function máximoEntre_Y_(primerValor, segundoValor){
    /*  Proposito: Describe el numero mas chico entre *primerValor* y el *segundoValor* 
        Precondicion: *primerValor* y *segundoValor* deber ser del mismo tipo
        Tipo:Numero || color || direccion : dependidiendo del tipo de valor que se ingrese como valor
        Parametros: *primerValor*, *segundoValor*: Numero,color,direccion : Son los valores a comparar
    */
    return (choose primerValor when (primerValor < segundoValor)
                   segundoValor otherwise     
            )
    
}

///EJERCICIO 18
function distanciaAlBorde_(direccion){
    /*
        Proposito:Describe la cantidad de celdas de distancia desde la celda actual hasta el borde *direccion*
        Precondicion:nignuno
        Parametro: direccion: Direccion - Es la direccion a contar las distancia
        Tipo:Numero
        Observacion: 
                    Es un recorrido de procesamiento
                    sobre las celdas de uan fila o columna
                     
    */
    distanciaAlbordeAlMomento := 0
    while (puedeMover(direccion)){
        Mover(direccion)
        distanciaAlbordeAlMomento :=distanciaAlbordeAlMomento +1    
    }
    return(distanciaAlbordeAlMomento)
}
///EJERCICIO 19
function coordenadaX(){
   /*
        Proposito: Describe la coordenada de la columna actual
        Precondicion:ninguna
        Tipo:numero
    */ 
    return(distanciaAlBorde_(Oeste))
}
function coordenadaY(){
   /*
        Proposito: Describe la coordenada de la fila actual
        Precondicion:ninguna
        Tipo:numero
    */ 
    return(distanciaAlBorde_(Sur))
}
------------
///EJERCICIO 20

function nroFilas(){
   /*
        Proposito:Describe la cantidad de filas del tablero
        Precondicion:ninguno
        Tipo:Numero
    */ 
    IrAlBorde_(Norte)
   return(  coordenadaY() +1 )
}
function nroColumnas(){
   /*
        Proposito:Describe la cantidad de columnas del tablero
        Precondicion:ninguno
        Tipo:Numero
    */ 
    IrAlBorde_(Este)
   return(  coordenadaX() +1 )
}
----------------------------
///EJERCICIO 21    
function nroVacias(){
  /*
        Proposito:Describe la cantidad de celdas vacias del tabero
        Precondicion:ninguna
        Tipo:Numero
        Observacion: 
                        Es un recorrido de acumulacion
                        sobre las celdas del tablero
                        contando todas las celdas vacias del tablero
    */  
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasVaciasAlMomento := unoSi_CeroSiNo( esCeldaVacia())
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        cantidadDeCeldasVaciasAlMomento := cantidadDeCeldasVaciasAlMomento + unoSi_CeroSiNo( esCeldaVacia())
    }
    return( cantidadDeCeldasVaciasAlMomento)
}   
----------------------------
///EJERCICIO 22 
function cantidadDeCeldasConBolitasDeColor_(color){
     /*
        Proposito:Describe la cantidad de celdas  que contienen al menos una bolita del color *color*
        Precondicion:ninguna
        Parametro: color: Color - Es el color a contar
        Tipo:Numero
        Observacion: 
                        Es un recorrido de acumulacion
                        sobre las celdas del tablero
                        contando todas las celdas que contienen al menos una bolita del color *color* del tablero
    */  
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasConBolitasVistas := unoSi_CeroSiNo(hayBolitas(color))
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        cantidadDeCeldasConBolitasVistas := cantidadDeCeldasConBolitasVistas + unoSi_CeroSiNo(hayBolitas(color))
    }
    return(cantidadDeCeldasConBolitasVistas)
}
---------------------------------
///EJERCICIO 23
function nroBolitasTotalDeColor_(colorAContar){
/*
        Proposito:Describe la cantidad de bolitas que hay en todo el tablero
        Precondicion:ninguna
        Parametro: colorAContar: Color - Es el color a contar
        Tipo:Numero
        Observacion: 
                        Es un recorrido de acumulacion
                        sobre las celdas del tablero
                        contando todas las bolitas del color *colorAContar* que hay en todo el tablero
    */      
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeBolitasVistas := nroBolitas(colorAContar)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        cantidadDeBolitasVistas := cantidadDeBolitasVistas +  nroBolitas(colorAContar)
    }
    return(cantidadDeBolitasVistas)
}
--------------------------------------------------------------

   // eejercicio 26
function unoSi_CeroSiNo(condicion){
    /*
        Proposito: Describe 1 si cumple la condicion *condicion* y sino cumple la condicion describe 0
        Precondicion:ninguno
        Parametros:*condicion* : Booleano
        Tipo:Numero
    */    
    return ( choose 1 when(condicion)
                    0 otherwise 
            )
}
-----------------------------------------------







